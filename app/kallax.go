// Code generated by https://github.com/src-d/go-kallax. DO NOT EDIT.
// Please, do not touch the code below, and if you do, do it under your own
// risk. Take into account that all the code you write here will be completely
// erased from earth the next time you generate the kallax models.
package app

import (
	"database/sql"
	"fmt"
	"time"

	"gopkg.in/src-d/go-kallax.v1"
	"gopkg.in/src-d/go-kallax.v1/types"
)

var _ types.SQLType
var _ fmt.Formatter

type modelSaveFunc func(*kallax.Store) error

// NewPoll returns a new instance of Poll.
func NewPoll() (record *Poll) {
	return new(Poll)
}

// GetID returns the primary key of the model.
func (r *Poll) GetID() kallax.Identifier {
	return (*kallax.ULID)(&r.ID)
}

// ColumnAddress returns the pointer to the value of the given column.
func (r *Poll) ColumnAddress(col string) (interface{}, error) {
	switch col {
	case "id":
		return (*kallax.ULID)(&r.ID), nil
	case "created_at":
		return &r.Timestamps.CreatedAt, nil
	case "updated_at":
		return &r.Timestamps.UpdatedAt, nil
	case "name":
		return &r.Name, nil
	case "owner":
		return &r.Owner, nil
	case "published":
		return &r.Published, nil

	default:
		return nil, fmt.Errorf("kallax: invalid column in Poll: %s", col)
	}
}

// Value returns the value of the given column.
func (r *Poll) Value(col string) (interface{}, error) {
	switch col {
	case "id":
		return r.ID, nil
	case "created_at":
		return r.Timestamps.CreatedAt, nil
	case "updated_at":
		return r.Timestamps.UpdatedAt, nil
	case "name":
		return r.Name, nil
	case "owner":
		return r.Owner, nil
	case "published":
		return r.Published, nil

	default:
		return nil, fmt.Errorf("kallax: invalid column in Poll: %s", col)
	}
}

// NewRelationshipRecord returns a new record for the relatiobship in the given
// field.
func (r *Poll) NewRelationshipRecord(field string) (kallax.Record, error) {
	switch field {
	case "Options":
		return new(PollOption), nil

	}
	return nil, fmt.Errorf("kallax: model Poll has no relationship %s", field)
}

// SetRelationship sets the given relationship in the given field.
func (r *Poll) SetRelationship(field string, rel interface{}) error {
	switch field {
	case "Options":
		records, ok := rel.([]kallax.Record)
		if !ok {
			return fmt.Errorf("kallax: relationship field %s needs a collection of records, not %T", field, rel)
		}

		r.Options = make([]*PollOption, len(records))
		for i, record := range records {
			rel, ok := record.(*PollOption)
			if !ok {
				return fmt.Errorf("kallax: element of type %T cannot be added to relationship %s", record, field)
			}
			r.Options[i] = rel
		}
		return nil

	}
	return fmt.Errorf("kallax: model Poll has no relationship %s", field)
}

// PollStore is the entity to access the records of the type Poll
// in the database.
type PollStore struct {
	*kallax.Store
}

// NewPollStore creates a new instance of PollStore
// using a SQL database.
func NewPollStore(db *sql.DB) *PollStore {
	return &PollStore{kallax.NewStore(db)}
}

// GenericStore returns the generic store of this store.
func (s *PollStore) GenericStore() *kallax.Store {
	return s.Store
}

// SetGenericStore changes the generic store of this store.
func (s *PollStore) SetGenericStore(store *kallax.Store) {
	s.Store = store
}

// Debug returns a new store that will print all SQL statements to stdout using
// the log.Printf function.
func (s *PollStore) Debug() *PollStore {
	return &PollStore{s.Store.Debug()}
}

// DebugWith returns a new store that will print all SQL statements using the
// given logger function.
func (s *PollStore) DebugWith(logger kallax.LoggerFunc) *PollStore {
	return &PollStore{s.Store.DebugWith(logger)}
}

// DisableCacher turns off prepared statements, which can be useful in some scenarios.
func (s *PollStore) DisableCacher() *PollStore {
	return &PollStore{s.Store.DisableCacher()}
}

func (s *PollStore) relationshipRecords(record *Poll) []modelSaveFunc {
	var result []modelSaveFunc

	for i := range record.Options {
		r := record.Options[i]
		if !r.IsSaving() {
			r.AddVirtualColumn("poll_id", record.GetID())
			result = append(result, func(store *kallax.Store) error {
				_, err := (&PollOptionStore{store}).Save(r)
				return err
			})
		}
	}

	return result
}

// Insert inserts a Poll in the database. A non-persisted object is
// required for this operation.
func (s *PollStore) Insert(record *Poll) error {
	record.SetSaving(true)
	defer record.SetSaving(false)

	record.CreatedAt = record.CreatedAt.Truncate(time.Microsecond)
	record.UpdatedAt = record.UpdatedAt.Truncate(time.Microsecond)

	if err := record.BeforeSave(); err != nil {
		return err
	}

	records := s.relationshipRecords(record)

	if len(records) > 0 {
		return s.Store.Transaction(func(s *kallax.Store) error {
			if err := s.Insert(Schema.Poll.BaseSchema, record); err != nil {
				return err
			}

			for _, r := range records {
				if err := r(s); err != nil {
					return err
				}
			}

			return nil
		})
	}

	return s.Store.Insert(Schema.Poll.BaseSchema, record)
}

// Update updates the given record on the database. If the columns are given,
// only these columns will be updated. Otherwise all of them will be.
// Be very careful with this, as you will have a potentially different object
// in memory but not on the database.
// Only writable records can be updated. Writable objects are those that have
// been just inserted or retrieved using a query with no custom select fields.
func (s *PollStore) Update(record *Poll, cols ...kallax.SchemaField) (updated int64, err error) {
	record.CreatedAt = record.CreatedAt.Truncate(time.Microsecond)
	record.UpdatedAt = record.UpdatedAt.Truncate(time.Microsecond)

	record.SetSaving(true)
	defer record.SetSaving(false)

	if err := record.BeforeSave(); err != nil {
		return 0, err
	}

	records := s.relationshipRecords(record)

	if len(records) > 0 {
		err = s.Store.Transaction(func(s *kallax.Store) error {
			updated, err = s.Update(Schema.Poll.BaseSchema, record, cols...)
			if err != nil {
				return err
			}

			for _, r := range records {
				if err := r(s); err != nil {
					return err
				}
			}

			return nil
		})
		if err != nil {
			return 0, err
		}

		return updated, nil
	}

	return s.Store.Update(Schema.Poll.BaseSchema, record, cols...)
}

// Save inserts the object if the record is not persisted, otherwise it updates
// it. Same rules of Update and Insert apply depending on the case.
func (s *PollStore) Save(record *Poll) (updated bool, err error) {
	if !record.IsPersisted() {
		return false, s.Insert(record)
	}

	rowsUpdated, err := s.Update(record)
	if err != nil {
		return false, err
	}

	return rowsUpdated > 0, nil
}

// Delete removes the given record from the database.
func (s *PollStore) Delete(record *Poll) error {
	return s.Store.Delete(Schema.Poll.BaseSchema, record)
}

// Find returns the set of results for the given query.
func (s *PollStore) Find(q *PollQuery) (*PollResultSet, error) {
	rs, err := s.Store.Find(q)
	if err != nil {
		return nil, err
	}

	return NewPollResultSet(rs), nil
}

// MustFind returns the set of results for the given query, but panics if there
// is any error.
func (s *PollStore) MustFind(q *PollQuery) *PollResultSet {
	return NewPollResultSet(s.Store.MustFind(q))
}

// Count returns the number of rows that would be retrieved with the given
// query.
func (s *PollStore) Count(q *PollQuery) (int64, error) {
	return s.Store.Count(q)
}

// MustCount returns the number of rows that would be retrieved with the given
// query, but panics if there is an error.
func (s *PollStore) MustCount(q *PollQuery) int64 {
	return s.Store.MustCount(q)
}

// FindOne returns the first row returned by the given query.
// `ErrNotFound` is returned if there are no results.
func (s *PollStore) FindOne(q *PollQuery) (*Poll, error) {
	q.Limit(1)
	q.Offset(0)
	rs, err := s.Find(q)
	if err != nil {
		return nil, err
	}

	if !rs.Next() {
		return nil, kallax.ErrNotFound
	}

	record, err := rs.Get()
	if err != nil {
		return nil, err
	}

	if err := rs.Close(); err != nil {
		return nil, err
	}

	return record, nil
}

// FindAll returns a list of all the rows returned by the given query.
func (s *PollStore) FindAll(q *PollQuery) ([]*Poll, error) {
	rs, err := s.Find(q)
	if err != nil {
		return nil, err
	}

	return rs.All()
}

// MustFindOne returns the first row retrieved by the given query. It panics
// if there is an error or if there are no rows.
func (s *PollStore) MustFindOne(q *PollQuery) *Poll {
	record, err := s.FindOne(q)
	if err != nil {
		panic(err)
	}
	return record
}

// Reload refreshes the Poll with the data in the database and
// makes it writable.
func (s *PollStore) Reload(record *Poll) error {
	return s.Store.Reload(Schema.Poll.BaseSchema, record)
}

// Transaction executes the given callback in a transaction and rollbacks if
// an error is returned.
// The transaction is only open in the store passed as a parameter to the
// callback.
func (s *PollStore) Transaction(callback func(*PollStore) error) error {
	if callback == nil {
		return kallax.ErrInvalidTxCallback
	}

	return s.Store.Transaction(func(store *kallax.Store) error {
		return callback(&PollStore{store})
	})
}

// RemoveOptions removes the given items of the Options field of the
// model. If no items are given, it removes all of them.
// The items will also be removed from the passed record inside this method.
// Note that is required that `Options` is not empty. This method clears the
// the elements of Options in a model, it does not retrieve them to know
// what relationships the model has.
func (s *PollStore) RemoveOptions(record *Poll, deleted ...*PollOption) error {
	var updated []*PollOption
	var clear bool
	if len(deleted) == 0 {
		clear = true
		deleted = record.Options
		if len(deleted) == 0 {
			return nil
		}
	}

	if len(deleted) > 1 {
		err := s.Store.Transaction(func(s *kallax.Store) error {
			for _, d := range deleted {
				var r kallax.Record = d

				if beforeDeleter, ok := r.(kallax.BeforeDeleter); ok {
					if err := beforeDeleter.BeforeDelete(); err != nil {
						return err
					}
				}

				if err := s.Delete(Schema.PollOption.BaseSchema, d); err != nil {
					return err
				}

				if afterDeleter, ok := r.(kallax.AfterDeleter); ok {
					if err := afterDeleter.AfterDelete(); err != nil {
						return err
					}
				}
			}
			return nil
		})

		if err != nil {
			return err
		}

		if clear {
			record.Options = nil
			return nil
		}
	} else {
		var r kallax.Record = deleted[0]
		if beforeDeleter, ok := r.(kallax.BeforeDeleter); ok {
			if err := beforeDeleter.BeforeDelete(); err != nil {
				return err
			}
		}

		var err error
		if afterDeleter, ok := r.(kallax.AfterDeleter); ok {
			err = s.Store.Transaction(func(s *kallax.Store) error {
				err := s.Delete(Schema.PollOption.BaseSchema, r)
				if err != nil {
					return err
				}

				return afterDeleter.AfterDelete()
			})
		} else {
			err = s.Store.Delete(Schema.PollOption.BaseSchema, deleted[0])
		}

		if err != nil {
			return err
		}
	}

	for _, r := range record.Options {
		var found bool
		for _, d := range deleted {
			if d.GetID().Equals(r.GetID()) {
				found = true
				break
			}
		}
		if !found {
			updated = append(updated, r)
		}
	}
	record.Options = updated
	return nil
}

// PollQuery is the object used to create queries for the Poll
// entity.
type PollQuery struct {
	*kallax.BaseQuery
}

// NewPollQuery returns a new instance of PollQuery.
func NewPollQuery() *PollQuery {
	return &PollQuery{
		BaseQuery: kallax.NewBaseQuery(Schema.Poll.BaseSchema),
	}
}

// Select adds columns to select in the query.
func (q *PollQuery) Select(columns ...kallax.SchemaField) *PollQuery {
	if len(columns) == 0 {
		return q
	}
	q.BaseQuery.Select(columns...)
	return q
}

// SelectNot excludes columns from being selected in the query.
func (q *PollQuery) SelectNot(columns ...kallax.SchemaField) *PollQuery {
	q.BaseQuery.SelectNot(columns...)
	return q
}

// Copy returns a new identical copy of the query. Remember queries are mutable
// so make a copy any time you need to reuse them.
func (q *PollQuery) Copy() *PollQuery {
	return &PollQuery{
		BaseQuery: q.BaseQuery.Copy(),
	}
}

// Order adds order clauses to the query for the given columns.
func (q *PollQuery) Order(cols ...kallax.ColumnOrder) *PollQuery {
	q.BaseQuery.Order(cols...)
	return q
}

// BatchSize sets the number of items to fetch per batch when there are 1:N
// relationships selected in the query.
func (q *PollQuery) BatchSize(size uint64) *PollQuery {
	q.BaseQuery.BatchSize(size)
	return q
}

// Limit sets the max number of items to retrieve.
func (q *PollQuery) Limit(n uint64) *PollQuery {
	q.BaseQuery.Limit(n)
	return q
}

// Offset sets the number of items to skip from the result set of items.
func (q *PollQuery) Offset(n uint64) *PollQuery {
	q.BaseQuery.Offset(n)
	return q
}

// Where adds a condition to the query. All conditions added are concatenated
// using a logical AND.
func (q *PollQuery) Where(cond kallax.Condition) *PollQuery {
	q.BaseQuery.Where(cond)
	return q
}

func (q *PollQuery) WithOptions(cond kallax.Condition) *PollQuery {
	q.AddRelation(Schema.PollOption.BaseSchema, "Options", kallax.OneToMany, cond)
	return q
}

// FindByID adds a new filter to the query that will require that
// the ID property is equal to one of the passed values; if no passed values,
// it will do nothing.
func (q *PollQuery) FindByID(v ...kallax.ULID) *PollQuery {
	if len(v) == 0 {
		return q
	}
	values := make([]interface{}, len(v))
	for i, val := range v {
		values[i] = val
	}
	return q.Where(kallax.In(Schema.Poll.ID, values...))
}

// FindByCreatedAt adds a new filter to the query that will require that
// the CreatedAt property is equal to the passed value.
func (q *PollQuery) FindByCreatedAt(cond kallax.ScalarCond, v time.Time) *PollQuery {
	return q.Where(cond(Schema.Poll.CreatedAt, v))
}

// FindByUpdatedAt adds a new filter to the query that will require that
// the UpdatedAt property is equal to the passed value.
func (q *PollQuery) FindByUpdatedAt(cond kallax.ScalarCond, v time.Time) *PollQuery {
	return q.Where(cond(Schema.Poll.UpdatedAt, v))
}

// FindByName adds a new filter to the query that will require that
// the Name property is equal to the passed value.
func (q *PollQuery) FindByName(v string) *PollQuery {
	return q.Where(kallax.Eq(Schema.Poll.Name, v))
}

// FindByOwner adds a new filter to the query that will require that
// the Owner property is equal to the passed value.
func (q *PollQuery) FindByOwner(v kallax.ULID) *PollQuery {
	return q.Where(kallax.Eq(Schema.Poll.Owner, v))
}

// FindByPublished adds a new filter to the query that will require that
// the Published property is equal to the passed value.
func (q *PollQuery) FindByPublished(v bool) *PollQuery {
	return q.Where(kallax.Eq(Schema.Poll.Published, v))
}

// PollResultSet is the set of results returned by a query to the
// database.
type PollResultSet struct {
	ResultSet kallax.ResultSet
	last      *Poll
	lastErr   error
}

// NewPollResultSet creates a new result set for rows of the type
// Poll.
func NewPollResultSet(rs kallax.ResultSet) *PollResultSet {
	return &PollResultSet{ResultSet: rs}
}

// Next fetches the next item in the result set and returns true if there is
// a next item.
// The result set is closed automatically when there are no more items.
func (rs *PollResultSet) Next() bool {
	if !rs.ResultSet.Next() {
		rs.lastErr = rs.ResultSet.Close()
		rs.last = nil
		return false
	}

	var record kallax.Record
	record, rs.lastErr = rs.ResultSet.Get(Schema.Poll.BaseSchema)
	if rs.lastErr != nil {
		rs.last = nil
	} else {
		var ok bool
		rs.last, ok = record.(*Poll)
		if !ok {
			rs.lastErr = fmt.Errorf("kallax: unable to convert record to *Poll")
			rs.last = nil
		}
	}

	return true
}

// Get retrieves the last fetched item from the result set and the last error.
func (rs *PollResultSet) Get() (*Poll, error) {
	return rs.last, rs.lastErr
}

// ForEach iterates over the complete result set passing every record found to
// the given callback. It is possible to stop the iteration by returning
// `kallax.ErrStop` in the callback.
// Result set is always closed at the end.
func (rs *PollResultSet) ForEach(fn func(*Poll) error) error {
	for rs.Next() {
		record, err := rs.Get()
		if err != nil {
			return err
		}

		if err := fn(record); err != nil {
			if err == kallax.ErrStop {
				return rs.Close()
			}

			return err
		}
	}
	return nil
}

// All returns all records on the result set and closes the result set.
func (rs *PollResultSet) All() ([]*Poll, error) {
	var result []*Poll
	for rs.Next() {
		record, err := rs.Get()
		if err != nil {
			return nil, err
		}
		result = append(result, record)
	}
	return result, nil
}

// One returns the first record on the result set and closes the result set.
func (rs *PollResultSet) One() (*Poll, error) {
	if !rs.Next() {
		return nil, kallax.ErrNotFound
	}

	record, err := rs.Get()
	if err != nil {
		return nil, err
	}

	if err := rs.Close(); err != nil {
		return nil, err
	}

	return record, nil
}

// Err returns the last error occurred.
func (rs *PollResultSet) Err() error {
	return rs.lastErr
}

// Close closes the result set.
func (rs *PollResultSet) Close() error {
	return rs.ResultSet.Close()
}

// NewPollOption returns a new instance of PollOption.
func NewPollOption() (record *PollOption) {
	return new(PollOption)
}

// GetID returns the primary key of the model.
func (r *PollOption) GetID() kallax.Identifier {
	return (*kallax.ULID)(&r.ID)
}

// ColumnAddress returns the pointer to the value of the given column.
func (r *PollOption) ColumnAddress(col string) (interface{}, error) {
	switch col {
	case "id":
		return (*kallax.ULID)(&r.ID), nil
	case "poll_id":
		return types.Nullable(kallax.VirtualColumn("poll_id", r, new(kallax.ULID))), nil
	case "content":
		return &r.Content, nil

	default:
		return nil, fmt.Errorf("kallax: invalid column in PollOption: %s", col)
	}
}

// Value returns the value of the given column.
func (r *PollOption) Value(col string) (interface{}, error) {
	switch col {
	case "id":
		return r.ID, nil
	case "poll_id":
		v := r.Model.VirtualColumn(col)
		if v == nil {
			return nil, kallax.ErrEmptyVirtualColumn
		}
		return v, nil
	case "content":
		return r.Content, nil

	default:
		return nil, fmt.Errorf("kallax: invalid column in PollOption: %s", col)
	}
}

// NewRelationshipRecord returns a new record for the relatiobship in the given
// field.
func (r *PollOption) NewRelationshipRecord(field string) (kallax.Record, error) {
	switch field {
	case "Owner":
		return new(Poll), nil

	}
	return nil, fmt.Errorf("kallax: model PollOption has no relationship %s", field)
}

// SetRelationship sets the given relationship in the given field.
func (r *PollOption) SetRelationship(field string, rel interface{}) error {
	switch field {
	case "Owner":
		val, ok := rel.(*Poll)
		if !ok {
			return fmt.Errorf("kallax: record of type %t can't be assigned to relationship Owner", rel)
		}
		if !val.GetID().IsEmpty() {
			r.Owner = val
		}

		return nil

	}
	return fmt.Errorf("kallax: model PollOption has no relationship %s", field)
}

// PollOptionStore is the entity to access the records of the type PollOption
// in the database.
type PollOptionStore struct {
	*kallax.Store
}

// NewPollOptionStore creates a new instance of PollOptionStore
// using a SQL database.
func NewPollOptionStore(db *sql.DB) *PollOptionStore {
	return &PollOptionStore{kallax.NewStore(db)}
}

// GenericStore returns the generic store of this store.
func (s *PollOptionStore) GenericStore() *kallax.Store {
	return s.Store
}

// SetGenericStore changes the generic store of this store.
func (s *PollOptionStore) SetGenericStore(store *kallax.Store) {
	s.Store = store
}

// Debug returns a new store that will print all SQL statements to stdout using
// the log.Printf function.
func (s *PollOptionStore) Debug() *PollOptionStore {
	return &PollOptionStore{s.Store.Debug()}
}

// DebugWith returns a new store that will print all SQL statements using the
// given logger function.
func (s *PollOptionStore) DebugWith(logger kallax.LoggerFunc) *PollOptionStore {
	return &PollOptionStore{s.Store.DebugWith(logger)}
}

// DisableCacher turns off prepared statements, which can be useful in some scenarios.
func (s *PollOptionStore) DisableCacher() *PollOptionStore {
	return &PollOptionStore{s.Store.DisableCacher()}
}

func (s *PollOptionStore) inverseRecords(record *PollOption) []modelSaveFunc {
	var result []modelSaveFunc

	if record.Owner != nil && !record.Owner.IsSaving() {
		record.AddVirtualColumn("poll_id", record.Owner.GetID())
		result = append(result, func(store *kallax.Store) error {
			_, err := (&PollStore{store}).Save(record.Owner)
			return err
		})
	}

	return result
}

// Insert inserts a PollOption in the database. A non-persisted object is
// required for this operation.
func (s *PollOptionStore) Insert(record *PollOption) error {
	record.SetSaving(true)
	defer record.SetSaving(false)

	inverseRecords := s.inverseRecords(record)

	if len(inverseRecords) > 0 {
		return s.Store.Transaction(func(s *kallax.Store) error {
			for _, r := range inverseRecords {
				if err := r(s); err != nil {
					return err
				}
			}

			if err := s.Insert(Schema.PollOption.BaseSchema, record); err != nil {
				return err
			}

			return nil
		})
	}

	return s.Store.Insert(Schema.PollOption.BaseSchema, record)
}

// Update updates the given record on the database. If the columns are given,
// only these columns will be updated. Otherwise all of them will be.
// Be very careful with this, as you will have a potentially different object
// in memory but not on the database.
// Only writable records can be updated. Writable objects are those that have
// been just inserted or retrieved using a query with no custom select fields.
func (s *PollOptionStore) Update(record *PollOption, cols ...kallax.SchemaField) (updated int64, err error) {
	record.SetSaving(true)
	defer record.SetSaving(false)

	inverseRecords := s.inverseRecords(record)

	if len(inverseRecords) > 0 {
		err = s.Store.Transaction(func(s *kallax.Store) error {
			for _, r := range inverseRecords {
				if err := r(s); err != nil {
					return err
				}
			}

			updated, err = s.Update(Schema.PollOption.BaseSchema, record, cols...)
			if err != nil {
				return err
			}

			return nil
		})
		if err != nil {
			return 0, err
		}

		return updated, nil
	}

	return s.Store.Update(Schema.PollOption.BaseSchema, record, cols...)
}

// Save inserts the object if the record is not persisted, otherwise it updates
// it. Same rules of Update and Insert apply depending on the case.
func (s *PollOptionStore) Save(record *PollOption) (updated bool, err error) {
	if !record.IsPersisted() {
		return false, s.Insert(record)
	}

	rowsUpdated, err := s.Update(record)
	if err != nil {
		return false, err
	}

	return rowsUpdated > 0, nil
}

// Delete removes the given record from the database.
func (s *PollOptionStore) Delete(record *PollOption) error {
	return s.Store.Delete(Schema.PollOption.BaseSchema, record)
}

// Find returns the set of results for the given query.
func (s *PollOptionStore) Find(q *PollOptionQuery) (*PollOptionResultSet, error) {
	rs, err := s.Store.Find(q)
	if err != nil {
		return nil, err
	}

	return NewPollOptionResultSet(rs), nil
}

// MustFind returns the set of results for the given query, but panics if there
// is any error.
func (s *PollOptionStore) MustFind(q *PollOptionQuery) *PollOptionResultSet {
	return NewPollOptionResultSet(s.Store.MustFind(q))
}

// Count returns the number of rows that would be retrieved with the given
// query.
func (s *PollOptionStore) Count(q *PollOptionQuery) (int64, error) {
	return s.Store.Count(q)
}

// MustCount returns the number of rows that would be retrieved with the given
// query, but panics if there is an error.
func (s *PollOptionStore) MustCount(q *PollOptionQuery) int64 {
	return s.Store.MustCount(q)
}

// FindOne returns the first row returned by the given query.
// `ErrNotFound` is returned if there are no results.
func (s *PollOptionStore) FindOne(q *PollOptionQuery) (*PollOption, error) {
	q.Limit(1)
	q.Offset(0)
	rs, err := s.Find(q)
	if err != nil {
		return nil, err
	}

	if !rs.Next() {
		return nil, kallax.ErrNotFound
	}

	record, err := rs.Get()
	if err != nil {
		return nil, err
	}

	if err := rs.Close(); err != nil {
		return nil, err
	}

	return record, nil
}

// FindAll returns a list of all the rows returned by the given query.
func (s *PollOptionStore) FindAll(q *PollOptionQuery) ([]*PollOption, error) {
	rs, err := s.Find(q)
	if err != nil {
		return nil, err
	}

	return rs.All()
}

// MustFindOne returns the first row retrieved by the given query. It panics
// if there is an error or if there are no rows.
func (s *PollOptionStore) MustFindOne(q *PollOptionQuery) *PollOption {
	record, err := s.FindOne(q)
	if err != nil {
		panic(err)
	}
	return record
}

// Reload refreshes the PollOption with the data in the database and
// makes it writable.
func (s *PollOptionStore) Reload(record *PollOption) error {
	return s.Store.Reload(Schema.PollOption.BaseSchema, record)
}

// Transaction executes the given callback in a transaction and rollbacks if
// an error is returned.
// The transaction is only open in the store passed as a parameter to the
// callback.
func (s *PollOptionStore) Transaction(callback func(*PollOptionStore) error) error {
	if callback == nil {
		return kallax.ErrInvalidTxCallback
	}

	return s.Store.Transaction(func(store *kallax.Store) error {
		return callback(&PollOptionStore{store})
	})
}

// PollOptionQuery is the object used to create queries for the PollOption
// entity.
type PollOptionQuery struct {
	*kallax.BaseQuery
}

// NewPollOptionQuery returns a new instance of PollOptionQuery.
func NewPollOptionQuery() *PollOptionQuery {
	return &PollOptionQuery{
		BaseQuery: kallax.NewBaseQuery(Schema.PollOption.BaseSchema),
	}
}

// Select adds columns to select in the query.
func (q *PollOptionQuery) Select(columns ...kallax.SchemaField) *PollOptionQuery {
	if len(columns) == 0 {
		return q
	}
	q.BaseQuery.Select(columns...)
	return q
}

// SelectNot excludes columns from being selected in the query.
func (q *PollOptionQuery) SelectNot(columns ...kallax.SchemaField) *PollOptionQuery {
	q.BaseQuery.SelectNot(columns...)
	return q
}

// Copy returns a new identical copy of the query. Remember queries are mutable
// so make a copy any time you need to reuse them.
func (q *PollOptionQuery) Copy() *PollOptionQuery {
	return &PollOptionQuery{
		BaseQuery: q.BaseQuery.Copy(),
	}
}

// Order adds order clauses to the query for the given columns.
func (q *PollOptionQuery) Order(cols ...kallax.ColumnOrder) *PollOptionQuery {
	q.BaseQuery.Order(cols...)
	return q
}

// BatchSize sets the number of items to fetch per batch when there are 1:N
// relationships selected in the query.
func (q *PollOptionQuery) BatchSize(size uint64) *PollOptionQuery {
	q.BaseQuery.BatchSize(size)
	return q
}

// Limit sets the max number of items to retrieve.
func (q *PollOptionQuery) Limit(n uint64) *PollOptionQuery {
	q.BaseQuery.Limit(n)
	return q
}

// Offset sets the number of items to skip from the result set of items.
func (q *PollOptionQuery) Offset(n uint64) *PollOptionQuery {
	q.BaseQuery.Offset(n)
	return q
}

// Where adds a condition to the query. All conditions added are concatenated
// using a logical AND.
func (q *PollOptionQuery) Where(cond kallax.Condition) *PollOptionQuery {
	q.BaseQuery.Where(cond)
	return q
}

func (q *PollOptionQuery) WithOwner() *PollOptionQuery {
	q.AddRelation(Schema.Poll.BaseSchema, "Owner", kallax.OneToOne, nil)
	return q
}

// FindByID adds a new filter to the query that will require that
// the ID property is equal to one of the passed values; if no passed values,
// it will do nothing.
func (q *PollOptionQuery) FindByID(v ...kallax.ULID) *PollOptionQuery {
	if len(v) == 0 {
		return q
	}
	values := make([]interface{}, len(v))
	for i, val := range v {
		values[i] = val
	}
	return q.Where(kallax.In(Schema.PollOption.ID, values...))
}

// FindByOwner adds a new filter to the query that will require that
// the foreign key of Owner is equal to the passed value.
func (q *PollOptionQuery) FindByOwner(v kallax.ULID) *PollOptionQuery {
	return q.Where(kallax.Eq(Schema.PollOption.OwnerFK, v))
}

// FindByContent adds a new filter to the query that will require that
// the Content property is equal to the passed value.
func (q *PollOptionQuery) FindByContent(v string) *PollOptionQuery {
	return q.Where(kallax.Eq(Schema.PollOption.Content, v))
}

// PollOptionResultSet is the set of results returned by a query to the
// database.
type PollOptionResultSet struct {
	ResultSet kallax.ResultSet
	last      *PollOption
	lastErr   error
}

// NewPollOptionResultSet creates a new result set for rows of the type
// PollOption.
func NewPollOptionResultSet(rs kallax.ResultSet) *PollOptionResultSet {
	return &PollOptionResultSet{ResultSet: rs}
}

// Next fetches the next item in the result set and returns true if there is
// a next item.
// The result set is closed automatically when there are no more items.
func (rs *PollOptionResultSet) Next() bool {
	if !rs.ResultSet.Next() {
		rs.lastErr = rs.ResultSet.Close()
		rs.last = nil
		return false
	}

	var record kallax.Record
	record, rs.lastErr = rs.ResultSet.Get(Schema.PollOption.BaseSchema)
	if rs.lastErr != nil {
		rs.last = nil
	} else {
		var ok bool
		rs.last, ok = record.(*PollOption)
		if !ok {
			rs.lastErr = fmt.Errorf("kallax: unable to convert record to *PollOption")
			rs.last = nil
		}
	}

	return true
}

// Get retrieves the last fetched item from the result set and the last error.
func (rs *PollOptionResultSet) Get() (*PollOption, error) {
	return rs.last, rs.lastErr
}

// ForEach iterates over the complete result set passing every record found to
// the given callback. It is possible to stop the iteration by returning
// `kallax.ErrStop` in the callback.
// Result set is always closed at the end.
func (rs *PollOptionResultSet) ForEach(fn func(*PollOption) error) error {
	for rs.Next() {
		record, err := rs.Get()
		if err != nil {
			return err
		}

		if err := fn(record); err != nil {
			if err == kallax.ErrStop {
				return rs.Close()
			}

			return err
		}
	}
	return nil
}

// All returns all records on the result set and closes the result set.
func (rs *PollOptionResultSet) All() ([]*PollOption, error) {
	var result []*PollOption
	for rs.Next() {
		record, err := rs.Get()
		if err != nil {
			return nil, err
		}
		result = append(result, record)
	}
	return result, nil
}

// One returns the first record on the result set and closes the result set.
func (rs *PollOptionResultSet) One() (*PollOption, error) {
	if !rs.Next() {
		return nil, kallax.ErrNotFound
	}

	record, err := rs.Get()
	if err != nil {
		return nil, err
	}

	if err := rs.Close(); err != nil {
		return nil, err
	}

	return record, nil
}

// Err returns the last error occurred.
func (rs *PollOptionResultSet) Err() error {
	return rs.lastErr
}

// Close closes the result set.
func (rs *PollOptionResultSet) Close() error {
	return rs.ResultSet.Close()
}

// NewPollVote returns a new instance of PollVote.
func NewPollVote() (record *PollVote) {
	return new(PollVote)
}

// GetID returns the primary key of the model.
func (r *PollVote) GetID() kallax.Identifier {
	return (*kallax.ULID)(&r.ID)
}

// ColumnAddress returns the pointer to the value of the given column.
func (r *PollVote) ColumnAddress(col string) (interface{}, error) {
	switch col {
	case "id":
		return (*kallax.ULID)(&r.ID), nil
	case "created_at":
		return &r.Timestamps.CreatedAt, nil
	case "updated_at":
		return &r.Timestamps.UpdatedAt, nil
	case "poll_id":
		return &r.PollID, nil
	case "user_id":
		return &r.UserID, nil
	case "chosen_option":
		return &r.ChosenOption, nil

	default:
		return nil, fmt.Errorf("kallax: invalid column in PollVote: %s", col)
	}
}

// Value returns the value of the given column.
func (r *PollVote) Value(col string) (interface{}, error) {
	switch col {
	case "id":
		return r.ID, nil
	case "created_at":
		return r.Timestamps.CreatedAt, nil
	case "updated_at":
		return r.Timestamps.UpdatedAt, nil
	case "poll_id":
		return r.PollID, nil
	case "user_id":
		return r.UserID, nil
	case "chosen_option":
		return r.ChosenOption, nil

	default:
		return nil, fmt.Errorf("kallax: invalid column in PollVote: %s", col)
	}
}

// NewRelationshipRecord returns a new record for the relatiobship in the given
// field.
func (r *PollVote) NewRelationshipRecord(field string) (kallax.Record, error) {
	return nil, fmt.Errorf("kallax: model PollVote has no relationships")
}

// SetRelationship sets the given relationship in the given field.
func (r *PollVote) SetRelationship(field string, rel interface{}) error {
	return fmt.Errorf("kallax: model PollVote has no relationships")
}

// PollVoteStore is the entity to access the records of the type PollVote
// in the database.
type PollVoteStore struct {
	*kallax.Store
}

// NewPollVoteStore creates a new instance of PollVoteStore
// using a SQL database.
func NewPollVoteStore(db *sql.DB) *PollVoteStore {
	return &PollVoteStore{kallax.NewStore(db)}
}

// GenericStore returns the generic store of this store.
func (s *PollVoteStore) GenericStore() *kallax.Store {
	return s.Store
}

// SetGenericStore changes the generic store of this store.
func (s *PollVoteStore) SetGenericStore(store *kallax.Store) {
	s.Store = store
}

// Debug returns a new store that will print all SQL statements to stdout using
// the log.Printf function.
func (s *PollVoteStore) Debug() *PollVoteStore {
	return &PollVoteStore{s.Store.Debug()}
}

// DebugWith returns a new store that will print all SQL statements using the
// given logger function.
func (s *PollVoteStore) DebugWith(logger kallax.LoggerFunc) *PollVoteStore {
	return &PollVoteStore{s.Store.DebugWith(logger)}
}

// DisableCacher turns off prepared statements, which can be useful in some scenarios.
func (s *PollVoteStore) DisableCacher() *PollVoteStore {
	return &PollVoteStore{s.Store.DisableCacher()}
}

// Insert inserts a PollVote in the database. A non-persisted object is
// required for this operation.
func (s *PollVoteStore) Insert(record *PollVote) error {
	record.SetSaving(true)
	defer record.SetSaving(false)

	record.CreatedAt = record.CreatedAt.Truncate(time.Microsecond)
	record.UpdatedAt = record.UpdatedAt.Truncate(time.Microsecond)

	if err := record.BeforeSave(); err != nil {
		return err
	}

	return s.Store.Insert(Schema.PollVote.BaseSchema, record)
}

// Update updates the given record on the database. If the columns are given,
// only these columns will be updated. Otherwise all of them will be.
// Be very careful with this, as you will have a potentially different object
// in memory but not on the database.
// Only writable records can be updated. Writable objects are those that have
// been just inserted or retrieved using a query with no custom select fields.
func (s *PollVoteStore) Update(record *PollVote, cols ...kallax.SchemaField) (updated int64, err error) {
	record.CreatedAt = record.CreatedAt.Truncate(time.Microsecond)
	record.UpdatedAt = record.UpdatedAt.Truncate(time.Microsecond)

	record.SetSaving(true)
	defer record.SetSaving(false)

	if err := record.BeforeSave(); err != nil {
		return 0, err
	}

	return s.Store.Update(Schema.PollVote.BaseSchema, record, cols...)
}

// Save inserts the object if the record is not persisted, otherwise it updates
// it. Same rules of Update and Insert apply depending on the case.
func (s *PollVoteStore) Save(record *PollVote) (updated bool, err error) {
	if !record.IsPersisted() {
		return false, s.Insert(record)
	}

	rowsUpdated, err := s.Update(record)
	if err != nil {
		return false, err
	}

	return rowsUpdated > 0, nil
}

// Delete removes the given record from the database.
func (s *PollVoteStore) Delete(record *PollVote) error {
	return s.Store.Delete(Schema.PollVote.BaseSchema, record)
}

// Find returns the set of results for the given query.
func (s *PollVoteStore) Find(q *PollVoteQuery) (*PollVoteResultSet, error) {
	rs, err := s.Store.Find(q)
	if err != nil {
		return nil, err
	}

	return NewPollVoteResultSet(rs), nil
}

// MustFind returns the set of results for the given query, but panics if there
// is any error.
func (s *PollVoteStore) MustFind(q *PollVoteQuery) *PollVoteResultSet {
	return NewPollVoteResultSet(s.Store.MustFind(q))
}

// Count returns the number of rows that would be retrieved with the given
// query.
func (s *PollVoteStore) Count(q *PollVoteQuery) (int64, error) {
	return s.Store.Count(q)
}

// MustCount returns the number of rows that would be retrieved with the given
// query, but panics if there is an error.
func (s *PollVoteStore) MustCount(q *PollVoteQuery) int64 {
	return s.Store.MustCount(q)
}

// FindOne returns the first row returned by the given query.
// `ErrNotFound` is returned if there are no results.
func (s *PollVoteStore) FindOne(q *PollVoteQuery) (*PollVote, error) {
	q.Limit(1)
	q.Offset(0)
	rs, err := s.Find(q)
	if err != nil {
		return nil, err
	}

	if !rs.Next() {
		return nil, kallax.ErrNotFound
	}

	record, err := rs.Get()
	if err != nil {
		return nil, err
	}

	if err := rs.Close(); err != nil {
		return nil, err
	}

	return record, nil
}

// FindAll returns a list of all the rows returned by the given query.
func (s *PollVoteStore) FindAll(q *PollVoteQuery) ([]*PollVote, error) {
	rs, err := s.Find(q)
	if err != nil {
		return nil, err
	}

	return rs.All()
}

// MustFindOne returns the first row retrieved by the given query. It panics
// if there is an error or if there are no rows.
func (s *PollVoteStore) MustFindOne(q *PollVoteQuery) *PollVote {
	record, err := s.FindOne(q)
	if err != nil {
		panic(err)
	}
	return record
}

// Reload refreshes the PollVote with the data in the database and
// makes it writable.
func (s *PollVoteStore) Reload(record *PollVote) error {
	return s.Store.Reload(Schema.PollVote.BaseSchema, record)
}

// Transaction executes the given callback in a transaction and rollbacks if
// an error is returned.
// The transaction is only open in the store passed as a parameter to the
// callback.
func (s *PollVoteStore) Transaction(callback func(*PollVoteStore) error) error {
	if callback == nil {
		return kallax.ErrInvalidTxCallback
	}

	return s.Store.Transaction(func(store *kallax.Store) error {
		return callback(&PollVoteStore{store})
	})
}

// PollVoteQuery is the object used to create queries for the PollVote
// entity.
type PollVoteQuery struct {
	*kallax.BaseQuery
}

// NewPollVoteQuery returns a new instance of PollVoteQuery.
func NewPollVoteQuery() *PollVoteQuery {
	return &PollVoteQuery{
		BaseQuery: kallax.NewBaseQuery(Schema.PollVote.BaseSchema),
	}
}

// Select adds columns to select in the query.
func (q *PollVoteQuery) Select(columns ...kallax.SchemaField) *PollVoteQuery {
	if len(columns) == 0 {
		return q
	}
	q.BaseQuery.Select(columns...)
	return q
}

// SelectNot excludes columns from being selected in the query.
func (q *PollVoteQuery) SelectNot(columns ...kallax.SchemaField) *PollVoteQuery {
	q.BaseQuery.SelectNot(columns...)
	return q
}

// Copy returns a new identical copy of the query. Remember queries are mutable
// so make a copy any time you need to reuse them.
func (q *PollVoteQuery) Copy() *PollVoteQuery {
	return &PollVoteQuery{
		BaseQuery: q.BaseQuery.Copy(),
	}
}

// Order adds order clauses to the query for the given columns.
func (q *PollVoteQuery) Order(cols ...kallax.ColumnOrder) *PollVoteQuery {
	q.BaseQuery.Order(cols...)
	return q
}

// BatchSize sets the number of items to fetch per batch when there are 1:N
// relationships selected in the query.
func (q *PollVoteQuery) BatchSize(size uint64) *PollVoteQuery {
	q.BaseQuery.BatchSize(size)
	return q
}

// Limit sets the max number of items to retrieve.
func (q *PollVoteQuery) Limit(n uint64) *PollVoteQuery {
	q.BaseQuery.Limit(n)
	return q
}

// Offset sets the number of items to skip from the result set of items.
func (q *PollVoteQuery) Offset(n uint64) *PollVoteQuery {
	q.BaseQuery.Offset(n)
	return q
}

// Where adds a condition to the query. All conditions added are concatenated
// using a logical AND.
func (q *PollVoteQuery) Where(cond kallax.Condition) *PollVoteQuery {
	q.BaseQuery.Where(cond)
	return q
}

// FindByID adds a new filter to the query that will require that
// the ID property is equal to one of the passed values; if no passed values,
// it will do nothing.
func (q *PollVoteQuery) FindByID(v ...kallax.ULID) *PollVoteQuery {
	if len(v) == 0 {
		return q
	}
	values := make([]interface{}, len(v))
	for i, val := range v {
		values[i] = val
	}
	return q.Where(kallax.In(Schema.PollVote.ID, values...))
}

// FindByCreatedAt adds a new filter to the query that will require that
// the CreatedAt property is equal to the passed value.
func (q *PollVoteQuery) FindByCreatedAt(cond kallax.ScalarCond, v time.Time) *PollVoteQuery {
	return q.Where(cond(Schema.PollVote.CreatedAt, v))
}

// FindByUpdatedAt adds a new filter to the query that will require that
// the UpdatedAt property is equal to the passed value.
func (q *PollVoteQuery) FindByUpdatedAt(cond kallax.ScalarCond, v time.Time) *PollVoteQuery {
	return q.Where(cond(Schema.PollVote.UpdatedAt, v))
}

// FindByPollID adds a new filter to the query that will require that
// the PollID property is equal to the passed value.
func (q *PollVoteQuery) FindByPollID(v kallax.ULID) *PollVoteQuery {
	return q.Where(kallax.Eq(Schema.PollVote.PollID, v))
}

// FindByUserID adds a new filter to the query that will require that
// the UserID property is equal to the passed value.
func (q *PollVoteQuery) FindByUserID(v kallax.ULID) *PollVoteQuery {
	return q.Where(kallax.Eq(Schema.PollVote.UserID, v))
}

// FindByChosenOption adds a new filter to the query that will require that
// the ChosenOption property is equal to the passed value.
func (q *PollVoteQuery) FindByChosenOption(v string) *PollVoteQuery {
	return q.Where(kallax.Eq(Schema.PollVote.ChosenOption, v))
}

// PollVoteResultSet is the set of results returned by a query to the
// database.
type PollVoteResultSet struct {
	ResultSet kallax.ResultSet
	last      *PollVote
	lastErr   error
}

// NewPollVoteResultSet creates a new result set for rows of the type
// PollVote.
func NewPollVoteResultSet(rs kallax.ResultSet) *PollVoteResultSet {
	return &PollVoteResultSet{ResultSet: rs}
}

// Next fetches the next item in the result set and returns true if there is
// a next item.
// The result set is closed automatically when there are no more items.
func (rs *PollVoteResultSet) Next() bool {
	if !rs.ResultSet.Next() {
		rs.lastErr = rs.ResultSet.Close()
		rs.last = nil
		return false
	}

	var record kallax.Record
	record, rs.lastErr = rs.ResultSet.Get(Schema.PollVote.BaseSchema)
	if rs.lastErr != nil {
		rs.last = nil
	} else {
		var ok bool
		rs.last, ok = record.(*PollVote)
		if !ok {
			rs.lastErr = fmt.Errorf("kallax: unable to convert record to *PollVote")
			rs.last = nil
		}
	}

	return true
}

// Get retrieves the last fetched item from the result set and the last error.
func (rs *PollVoteResultSet) Get() (*PollVote, error) {
	return rs.last, rs.lastErr
}

// ForEach iterates over the complete result set passing every record found to
// the given callback. It is possible to stop the iteration by returning
// `kallax.ErrStop` in the callback.
// Result set is always closed at the end.
func (rs *PollVoteResultSet) ForEach(fn func(*PollVote) error) error {
	for rs.Next() {
		record, err := rs.Get()
		if err != nil {
			return err
		}

		if err := fn(record); err != nil {
			if err == kallax.ErrStop {
				return rs.Close()
			}

			return err
		}
	}
	return nil
}

// All returns all records on the result set and closes the result set.
func (rs *PollVoteResultSet) All() ([]*PollVote, error) {
	var result []*PollVote
	for rs.Next() {
		record, err := rs.Get()
		if err != nil {
			return nil, err
		}
		result = append(result, record)
	}
	return result, nil
}

// One returns the first record on the result set and closes the result set.
func (rs *PollVoteResultSet) One() (*PollVote, error) {
	if !rs.Next() {
		return nil, kallax.ErrNotFound
	}

	record, err := rs.Get()
	if err != nil {
		return nil, err
	}

	if err := rs.Close(); err != nil {
		return nil, err
	}

	return record, nil
}

// Err returns the last error occurred.
func (rs *PollVoteResultSet) Err() error {
	return rs.lastErr
}

// Close closes the result set.
func (rs *PollVoteResultSet) Close() error {
	return rs.ResultSet.Close()
}

// NewSession returns a new instance of Session.
func NewSession() (record *Session) {
	return new(Session)
}

// GetID returns the primary key of the model.
func (r *Session) GetID() kallax.Identifier {
	return (*kallax.ULID)(&r.ID)
}

// ColumnAddress returns the pointer to the value of the given column.
func (r *Session) ColumnAddress(col string) (interface{}, error) {
	switch col {
	case "id":
		return (*kallax.ULID)(&r.ID), nil
	case "created_at":
		return &r.Timestamps.CreatedAt, nil
	case "updated_at":
		return &r.Timestamps.UpdatedAt, nil
	case "user_id":
		return &r.UserID, nil
	case "registered_user":
		return &r.RegisteredUser, nil

	default:
		return nil, fmt.Errorf("kallax: invalid column in Session: %s", col)
	}
}

// Value returns the value of the given column.
func (r *Session) Value(col string) (interface{}, error) {
	switch col {
	case "id":
		return r.ID, nil
	case "created_at":
		return r.Timestamps.CreatedAt, nil
	case "updated_at":
		return r.Timestamps.UpdatedAt, nil
	case "user_id":
		return r.UserID, nil
	case "registered_user":
		return r.RegisteredUser, nil

	default:
		return nil, fmt.Errorf("kallax: invalid column in Session: %s", col)
	}
}

// NewRelationshipRecord returns a new record for the relatiobship in the given
// field.
func (r *Session) NewRelationshipRecord(field string) (kallax.Record, error) {
	return nil, fmt.Errorf("kallax: model Session has no relationships")
}

// SetRelationship sets the given relationship in the given field.
func (r *Session) SetRelationship(field string, rel interface{}) error {
	return fmt.Errorf("kallax: model Session has no relationships")
}

// SessionStore is the entity to access the records of the type Session
// in the database.
type SessionStore struct {
	*kallax.Store
}

// NewSessionStore creates a new instance of SessionStore
// using a SQL database.
func NewSessionStore(db *sql.DB) *SessionStore {
	return &SessionStore{kallax.NewStore(db)}
}

// GenericStore returns the generic store of this store.
func (s *SessionStore) GenericStore() *kallax.Store {
	return s.Store
}

// SetGenericStore changes the generic store of this store.
func (s *SessionStore) SetGenericStore(store *kallax.Store) {
	s.Store = store
}

// Debug returns a new store that will print all SQL statements to stdout using
// the log.Printf function.
func (s *SessionStore) Debug() *SessionStore {
	return &SessionStore{s.Store.Debug()}
}

// DebugWith returns a new store that will print all SQL statements using the
// given logger function.
func (s *SessionStore) DebugWith(logger kallax.LoggerFunc) *SessionStore {
	return &SessionStore{s.Store.DebugWith(logger)}
}

// DisableCacher turns off prepared statements, which can be useful in some scenarios.
func (s *SessionStore) DisableCacher() *SessionStore {
	return &SessionStore{s.Store.DisableCacher()}
}

// Insert inserts a Session in the database. A non-persisted object is
// required for this operation.
func (s *SessionStore) Insert(record *Session) error {
	record.SetSaving(true)
	defer record.SetSaving(false)

	record.CreatedAt = record.CreatedAt.Truncate(time.Microsecond)
	record.UpdatedAt = record.UpdatedAt.Truncate(time.Microsecond)

	if err := record.BeforeSave(); err != nil {
		return err
	}

	return s.Store.Insert(Schema.Session.BaseSchema, record)
}

// Update updates the given record on the database. If the columns are given,
// only these columns will be updated. Otherwise all of them will be.
// Be very careful with this, as you will have a potentially different object
// in memory but not on the database.
// Only writable records can be updated. Writable objects are those that have
// been just inserted or retrieved using a query with no custom select fields.
func (s *SessionStore) Update(record *Session, cols ...kallax.SchemaField) (updated int64, err error) {
	record.CreatedAt = record.CreatedAt.Truncate(time.Microsecond)
	record.UpdatedAt = record.UpdatedAt.Truncate(time.Microsecond)

	record.SetSaving(true)
	defer record.SetSaving(false)

	if err := record.BeforeSave(); err != nil {
		return 0, err
	}

	return s.Store.Update(Schema.Session.BaseSchema, record, cols...)
}

// Save inserts the object if the record is not persisted, otherwise it updates
// it. Same rules of Update and Insert apply depending on the case.
func (s *SessionStore) Save(record *Session) (updated bool, err error) {
	if !record.IsPersisted() {
		return false, s.Insert(record)
	}

	rowsUpdated, err := s.Update(record)
	if err != nil {
		return false, err
	}

	return rowsUpdated > 0, nil
}

// Delete removes the given record from the database.
func (s *SessionStore) Delete(record *Session) error {
	return s.Store.Delete(Schema.Session.BaseSchema, record)
}

// Find returns the set of results for the given query.
func (s *SessionStore) Find(q *SessionQuery) (*SessionResultSet, error) {
	rs, err := s.Store.Find(q)
	if err != nil {
		return nil, err
	}

	return NewSessionResultSet(rs), nil
}

// MustFind returns the set of results for the given query, but panics if there
// is any error.
func (s *SessionStore) MustFind(q *SessionQuery) *SessionResultSet {
	return NewSessionResultSet(s.Store.MustFind(q))
}

// Count returns the number of rows that would be retrieved with the given
// query.
func (s *SessionStore) Count(q *SessionQuery) (int64, error) {
	return s.Store.Count(q)
}

// MustCount returns the number of rows that would be retrieved with the given
// query, but panics if there is an error.
func (s *SessionStore) MustCount(q *SessionQuery) int64 {
	return s.Store.MustCount(q)
}

// FindOne returns the first row returned by the given query.
// `ErrNotFound` is returned if there are no results.
func (s *SessionStore) FindOne(q *SessionQuery) (*Session, error) {
	q.Limit(1)
	q.Offset(0)
	rs, err := s.Find(q)
	if err != nil {
		return nil, err
	}

	if !rs.Next() {
		return nil, kallax.ErrNotFound
	}

	record, err := rs.Get()
	if err != nil {
		return nil, err
	}

	if err := rs.Close(); err != nil {
		return nil, err
	}

	return record, nil
}

// FindAll returns a list of all the rows returned by the given query.
func (s *SessionStore) FindAll(q *SessionQuery) ([]*Session, error) {
	rs, err := s.Find(q)
	if err != nil {
		return nil, err
	}

	return rs.All()
}

// MustFindOne returns the first row retrieved by the given query. It panics
// if there is an error or if there are no rows.
func (s *SessionStore) MustFindOne(q *SessionQuery) *Session {
	record, err := s.FindOne(q)
	if err != nil {
		panic(err)
	}
	return record
}

// Reload refreshes the Session with the data in the database and
// makes it writable.
func (s *SessionStore) Reload(record *Session) error {
	return s.Store.Reload(Schema.Session.BaseSchema, record)
}

// Transaction executes the given callback in a transaction and rollbacks if
// an error is returned.
// The transaction is only open in the store passed as a parameter to the
// callback.
func (s *SessionStore) Transaction(callback func(*SessionStore) error) error {
	if callback == nil {
		return kallax.ErrInvalidTxCallback
	}

	return s.Store.Transaction(func(store *kallax.Store) error {
		return callback(&SessionStore{store})
	})
}

// SessionQuery is the object used to create queries for the Session
// entity.
type SessionQuery struct {
	*kallax.BaseQuery
}

// NewSessionQuery returns a new instance of SessionQuery.
func NewSessionQuery() *SessionQuery {
	return &SessionQuery{
		BaseQuery: kallax.NewBaseQuery(Schema.Session.BaseSchema),
	}
}

// Select adds columns to select in the query.
func (q *SessionQuery) Select(columns ...kallax.SchemaField) *SessionQuery {
	if len(columns) == 0 {
		return q
	}
	q.BaseQuery.Select(columns...)
	return q
}

// SelectNot excludes columns from being selected in the query.
func (q *SessionQuery) SelectNot(columns ...kallax.SchemaField) *SessionQuery {
	q.BaseQuery.SelectNot(columns...)
	return q
}

// Copy returns a new identical copy of the query. Remember queries are mutable
// so make a copy any time you need to reuse them.
func (q *SessionQuery) Copy() *SessionQuery {
	return &SessionQuery{
		BaseQuery: q.BaseQuery.Copy(),
	}
}

// Order adds order clauses to the query for the given columns.
func (q *SessionQuery) Order(cols ...kallax.ColumnOrder) *SessionQuery {
	q.BaseQuery.Order(cols...)
	return q
}

// BatchSize sets the number of items to fetch per batch when there are 1:N
// relationships selected in the query.
func (q *SessionQuery) BatchSize(size uint64) *SessionQuery {
	q.BaseQuery.BatchSize(size)
	return q
}

// Limit sets the max number of items to retrieve.
func (q *SessionQuery) Limit(n uint64) *SessionQuery {
	q.BaseQuery.Limit(n)
	return q
}

// Offset sets the number of items to skip from the result set of items.
func (q *SessionQuery) Offset(n uint64) *SessionQuery {
	q.BaseQuery.Offset(n)
	return q
}

// Where adds a condition to the query. All conditions added are concatenated
// using a logical AND.
func (q *SessionQuery) Where(cond kallax.Condition) *SessionQuery {
	q.BaseQuery.Where(cond)
	return q
}

// FindByID adds a new filter to the query that will require that
// the ID property is equal to one of the passed values; if no passed values,
// it will do nothing.
func (q *SessionQuery) FindByID(v ...kallax.ULID) *SessionQuery {
	if len(v) == 0 {
		return q
	}
	values := make([]interface{}, len(v))
	for i, val := range v {
		values[i] = val
	}
	return q.Where(kallax.In(Schema.Session.ID, values...))
}

// FindByCreatedAt adds a new filter to the query that will require that
// the CreatedAt property is equal to the passed value.
func (q *SessionQuery) FindByCreatedAt(cond kallax.ScalarCond, v time.Time) *SessionQuery {
	return q.Where(cond(Schema.Session.CreatedAt, v))
}

// FindByUpdatedAt adds a new filter to the query that will require that
// the UpdatedAt property is equal to the passed value.
func (q *SessionQuery) FindByUpdatedAt(cond kallax.ScalarCond, v time.Time) *SessionQuery {
	return q.Where(cond(Schema.Session.UpdatedAt, v))
}

// FindByUserID adds a new filter to the query that will require that
// the UserID property is equal to the passed value.
func (q *SessionQuery) FindByUserID(v kallax.ULID) *SessionQuery {
	return q.Where(kallax.Eq(Schema.Session.UserID, v))
}

// FindByRegisteredUser adds a new filter to the query that will require that
// the RegisteredUser property is equal to the passed value.
func (q *SessionQuery) FindByRegisteredUser(v bool) *SessionQuery {
	return q.Where(kallax.Eq(Schema.Session.RegisteredUser, v))
}

// SessionResultSet is the set of results returned by a query to the
// database.
type SessionResultSet struct {
	ResultSet kallax.ResultSet
	last      *Session
	lastErr   error
}

// NewSessionResultSet creates a new result set for rows of the type
// Session.
func NewSessionResultSet(rs kallax.ResultSet) *SessionResultSet {
	return &SessionResultSet{ResultSet: rs}
}

// Next fetches the next item in the result set and returns true if there is
// a next item.
// The result set is closed automatically when there are no more items.
func (rs *SessionResultSet) Next() bool {
	if !rs.ResultSet.Next() {
		rs.lastErr = rs.ResultSet.Close()
		rs.last = nil
		return false
	}

	var record kallax.Record
	record, rs.lastErr = rs.ResultSet.Get(Schema.Session.BaseSchema)
	if rs.lastErr != nil {
		rs.last = nil
	} else {
		var ok bool
		rs.last, ok = record.(*Session)
		if !ok {
			rs.lastErr = fmt.Errorf("kallax: unable to convert record to *Session")
			rs.last = nil
		}
	}

	return true
}

// Get retrieves the last fetched item from the result set and the last error.
func (rs *SessionResultSet) Get() (*Session, error) {
	return rs.last, rs.lastErr
}

// ForEach iterates over the complete result set passing every record found to
// the given callback. It is possible to stop the iteration by returning
// `kallax.ErrStop` in the callback.
// Result set is always closed at the end.
func (rs *SessionResultSet) ForEach(fn func(*Session) error) error {
	for rs.Next() {
		record, err := rs.Get()
		if err != nil {
			return err
		}

		if err := fn(record); err != nil {
			if err == kallax.ErrStop {
				return rs.Close()
			}

			return err
		}
	}
	return nil
}

// All returns all records on the result set and closes the result set.
func (rs *SessionResultSet) All() ([]*Session, error) {
	var result []*Session
	for rs.Next() {
		record, err := rs.Get()
		if err != nil {
			return nil, err
		}
		result = append(result, record)
	}
	return result, nil
}

// One returns the first record on the result set and closes the result set.
func (rs *SessionResultSet) One() (*Session, error) {
	if !rs.Next() {
		return nil, kallax.ErrNotFound
	}

	record, err := rs.Get()
	if err != nil {
		return nil, err
	}

	if err := rs.Close(); err != nil {
		return nil, err
	}

	return record, nil
}

// Err returns the last error occurred.
func (rs *SessionResultSet) Err() error {
	return rs.lastErr
}

// Close closes the result set.
func (rs *SessionResultSet) Close() error {
	return rs.ResultSet.Close()
}

// NewUser returns a new instance of User.
func NewUser() (record *User) {
	return new(User)
}

// GetID returns the primary key of the model.
func (r *User) GetID() kallax.Identifier {
	return (*kallax.ULID)(&r.ID)
}

// ColumnAddress returns the pointer to the value of the given column.
func (r *User) ColumnAddress(col string) (interface{}, error) {
	switch col {
	case "id":
		return (*kallax.ULID)(&r.ID), nil
	case "created_at":
		return &r.Timestamps.CreatedAt, nil
	case "updated_at":
		return &r.Timestamps.UpdatedAt, nil
	case "login":
		return &r.Login, nil
	case "name":
		return &r.Name, nil
	case "password":
		return &r.Password, nil

	default:
		return nil, fmt.Errorf("kallax: invalid column in User: %s", col)
	}
}

// Value returns the value of the given column.
func (r *User) Value(col string) (interface{}, error) {
	switch col {
	case "id":
		return r.ID, nil
	case "created_at":
		return r.Timestamps.CreatedAt, nil
	case "updated_at":
		return r.Timestamps.UpdatedAt, nil
	case "login":
		return r.Login, nil
	case "name":
		return r.Name, nil
	case "password":
		return r.Password, nil

	default:
		return nil, fmt.Errorf("kallax: invalid column in User: %s", col)
	}
}

// NewRelationshipRecord returns a new record for the relatiobship in the given
// field.
func (r *User) NewRelationshipRecord(field string) (kallax.Record, error) {
	return nil, fmt.Errorf("kallax: model User has no relationships")
}

// SetRelationship sets the given relationship in the given field.
func (r *User) SetRelationship(field string, rel interface{}) error {
	return fmt.Errorf("kallax: model User has no relationships")
}

// UserStore is the entity to access the records of the type User
// in the database.
type UserStore struct {
	*kallax.Store
}

// NewUserStore creates a new instance of UserStore
// using a SQL database.
func NewUserStore(db *sql.DB) *UserStore {
	return &UserStore{kallax.NewStore(db)}
}

// GenericStore returns the generic store of this store.
func (s *UserStore) GenericStore() *kallax.Store {
	return s.Store
}

// SetGenericStore changes the generic store of this store.
func (s *UserStore) SetGenericStore(store *kallax.Store) {
	s.Store = store
}

// Debug returns a new store that will print all SQL statements to stdout using
// the log.Printf function.
func (s *UserStore) Debug() *UserStore {
	return &UserStore{s.Store.Debug()}
}

// DebugWith returns a new store that will print all SQL statements using the
// given logger function.
func (s *UserStore) DebugWith(logger kallax.LoggerFunc) *UserStore {
	return &UserStore{s.Store.DebugWith(logger)}
}

// DisableCacher turns off prepared statements, which can be useful in some scenarios.
func (s *UserStore) DisableCacher() *UserStore {
	return &UserStore{s.Store.DisableCacher()}
}

// Insert inserts a User in the database. A non-persisted object is
// required for this operation.
func (s *UserStore) Insert(record *User) error {
	record.SetSaving(true)
	defer record.SetSaving(false)

	record.CreatedAt = record.CreatedAt.Truncate(time.Microsecond)
	record.UpdatedAt = record.UpdatedAt.Truncate(time.Microsecond)

	if err := record.BeforeSave(); err != nil {
		return err
	}

	return s.Store.Insert(Schema.User.BaseSchema, record)
}

// Update updates the given record on the database. If the columns are given,
// only these columns will be updated. Otherwise all of them will be.
// Be very careful with this, as you will have a potentially different object
// in memory but not on the database.
// Only writable records can be updated. Writable objects are those that have
// been just inserted or retrieved using a query with no custom select fields.
func (s *UserStore) Update(record *User, cols ...kallax.SchemaField) (updated int64, err error) {
	record.CreatedAt = record.CreatedAt.Truncate(time.Microsecond)
	record.UpdatedAt = record.UpdatedAt.Truncate(time.Microsecond)

	record.SetSaving(true)
	defer record.SetSaving(false)

	if err := record.BeforeSave(); err != nil {
		return 0, err
	}

	return s.Store.Update(Schema.User.BaseSchema, record, cols...)
}

// Save inserts the object if the record is not persisted, otherwise it updates
// it. Same rules of Update and Insert apply depending on the case.
func (s *UserStore) Save(record *User) (updated bool, err error) {
	if !record.IsPersisted() {
		return false, s.Insert(record)
	}

	rowsUpdated, err := s.Update(record)
	if err != nil {
		return false, err
	}

	return rowsUpdated > 0, nil
}

// Delete removes the given record from the database.
func (s *UserStore) Delete(record *User) error {
	return s.Store.Delete(Schema.User.BaseSchema, record)
}

// Find returns the set of results for the given query.
func (s *UserStore) Find(q *UserQuery) (*UserResultSet, error) {
	rs, err := s.Store.Find(q)
	if err != nil {
		return nil, err
	}

	return NewUserResultSet(rs), nil
}

// MustFind returns the set of results for the given query, but panics if there
// is any error.
func (s *UserStore) MustFind(q *UserQuery) *UserResultSet {
	return NewUserResultSet(s.Store.MustFind(q))
}

// Count returns the number of rows that would be retrieved with the given
// query.
func (s *UserStore) Count(q *UserQuery) (int64, error) {
	return s.Store.Count(q)
}

// MustCount returns the number of rows that would be retrieved with the given
// query, but panics if there is an error.
func (s *UserStore) MustCount(q *UserQuery) int64 {
	return s.Store.MustCount(q)
}

// FindOne returns the first row returned by the given query.
// `ErrNotFound` is returned if there are no results.
func (s *UserStore) FindOne(q *UserQuery) (*User, error) {
	q.Limit(1)
	q.Offset(0)
	rs, err := s.Find(q)
	if err != nil {
		return nil, err
	}

	if !rs.Next() {
		return nil, kallax.ErrNotFound
	}

	record, err := rs.Get()
	if err != nil {
		return nil, err
	}

	if err := rs.Close(); err != nil {
		return nil, err
	}

	return record, nil
}

// FindAll returns a list of all the rows returned by the given query.
func (s *UserStore) FindAll(q *UserQuery) ([]*User, error) {
	rs, err := s.Find(q)
	if err != nil {
		return nil, err
	}

	return rs.All()
}

// MustFindOne returns the first row retrieved by the given query. It panics
// if there is an error or if there are no rows.
func (s *UserStore) MustFindOne(q *UserQuery) *User {
	record, err := s.FindOne(q)
	if err != nil {
		panic(err)
	}
	return record
}

// Reload refreshes the User with the data in the database and
// makes it writable.
func (s *UserStore) Reload(record *User) error {
	return s.Store.Reload(Schema.User.BaseSchema, record)
}

// Transaction executes the given callback in a transaction and rollbacks if
// an error is returned.
// The transaction is only open in the store passed as a parameter to the
// callback.
func (s *UserStore) Transaction(callback func(*UserStore) error) error {
	if callback == nil {
		return kallax.ErrInvalidTxCallback
	}

	return s.Store.Transaction(func(store *kallax.Store) error {
		return callback(&UserStore{store})
	})
}

// UserQuery is the object used to create queries for the User
// entity.
type UserQuery struct {
	*kallax.BaseQuery
}

// NewUserQuery returns a new instance of UserQuery.
func NewUserQuery() *UserQuery {
	return &UserQuery{
		BaseQuery: kallax.NewBaseQuery(Schema.User.BaseSchema),
	}
}

// Select adds columns to select in the query.
func (q *UserQuery) Select(columns ...kallax.SchemaField) *UserQuery {
	if len(columns) == 0 {
		return q
	}
	q.BaseQuery.Select(columns...)
	return q
}

// SelectNot excludes columns from being selected in the query.
func (q *UserQuery) SelectNot(columns ...kallax.SchemaField) *UserQuery {
	q.BaseQuery.SelectNot(columns...)
	return q
}

// Copy returns a new identical copy of the query. Remember queries are mutable
// so make a copy any time you need to reuse them.
func (q *UserQuery) Copy() *UserQuery {
	return &UserQuery{
		BaseQuery: q.BaseQuery.Copy(),
	}
}

// Order adds order clauses to the query for the given columns.
func (q *UserQuery) Order(cols ...kallax.ColumnOrder) *UserQuery {
	q.BaseQuery.Order(cols...)
	return q
}

// BatchSize sets the number of items to fetch per batch when there are 1:N
// relationships selected in the query.
func (q *UserQuery) BatchSize(size uint64) *UserQuery {
	q.BaseQuery.BatchSize(size)
	return q
}

// Limit sets the max number of items to retrieve.
func (q *UserQuery) Limit(n uint64) *UserQuery {
	q.BaseQuery.Limit(n)
	return q
}

// Offset sets the number of items to skip from the result set of items.
func (q *UserQuery) Offset(n uint64) *UserQuery {
	q.BaseQuery.Offset(n)
	return q
}

// Where adds a condition to the query. All conditions added are concatenated
// using a logical AND.
func (q *UserQuery) Where(cond kallax.Condition) *UserQuery {
	q.BaseQuery.Where(cond)
	return q
}

// FindByID adds a new filter to the query that will require that
// the ID property is equal to one of the passed values; if no passed values,
// it will do nothing.
func (q *UserQuery) FindByID(v ...kallax.ULID) *UserQuery {
	if len(v) == 0 {
		return q
	}
	values := make([]interface{}, len(v))
	for i, val := range v {
		values[i] = val
	}
	return q.Where(kallax.In(Schema.User.ID, values...))
}

// FindByCreatedAt adds a new filter to the query that will require that
// the CreatedAt property is equal to the passed value.
func (q *UserQuery) FindByCreatedAt(cond kallax.ScalarCond, v time.Time) *UserQuery {
	return q.Where(cond(Schema.User.CreatedAt, v))
}

// FindByUpdatedAt adds a new filter to the query that will require that
// the UpdatedAt property is equal to the passed value.
func (q *UserQuery) FindByUpdatedAt(cond kallax.ScalarCond, v time.Time) *UserQuery {
	return q.Where(cond(Schema.User.UpdatedAt, v))
}

// FindByLogin adds a new filter to the query that will require that
// the Login property is equal to the passed value.
func (q *UserQuery) FindByLogin(v string) *UserQuery {
	return q.Where(kallax.Eq(Schema.User.Login, v))
}

// FindByName adds a new filter to the query that will require that
// the Name property is equal to the passed value.
func (q *UserQuery) FindByName(v string) *UserQuery {
	return q.Where(kallax.Eq(Schema.User.Name, v))
}

// FindByPassword adds a new filter to the query that will require that
// the Password property is equal to the passed value.
func (q *UserQuery) FindByPassword(v string) *UserQuery {
	return q.Where(kallax.Eq(Schema.User.Password, v))
}

// UserResultSet is the set of results returned by a query to the
// database.
type UserResultSet struct {
	ResultSet kallax.ResultSet
	last      *User
	lastErr   error
}

// NewUserResultSet creates a new result set for rows of the type
// User.
func NewUserResultSet(rs kallax.ResultSet) *UserResultSet {
	return &UserResultSet{ResultSet: rs}
}

// Next fetches the next item in the result set and returns true if there is
// a next item.
// The result set is closed automatically when there are no more items.
func (rs *UserResultSet) Next() bool {
	if !rs.ResultSet.Next() {
		rs.lastErr = rs.ResultSet.Close()
		rs.last = nil
		return false
	}

	var record kallax.Record
	record, rs.lastErr = rs.ResultSet.Get(Schema.User.BaseSchema)
	if rs.lastErr != nil {
		rs.last = nil
	} else {
		var ok bool
		rs.last, ok = record.(*User)
		if !ok {
			rs.lastErr = fmt.Errorf("kallax: unable to convert record to *User")
			rs.last = nil
		}
	}

	return true
}

// Get retrieves the last fetched item from the result set and the last error.
func (rs *UserResultSet) Get() (*User, error) {
	return rs.last, rs.lastErr
}

// ForEach iterates over the complete result set passing every record found to
// the given callback. It is possible to stop the iteration by returning
// `kallax.ErrStop` in the callback.
// Result set is always closed at the end.
func (rs *UserResultSet) ForEach(fn func(*User) error) error {
	for rs.Next() {
		record, err := rs.Get()
		if err != nil {
			return err
		}

		if err := fn(record); err != nil {
			if err == kallax.ErrStop {
				return rs.Close()
			}

			return err
		}
	}
	return nil
}

// All returns all records on the result set and closes the result set.
func (rs *UserResultSet) All() ([]*User, error) {
	var result []*User
	for rs.Next() {
		record, err := rs.Get()
		if err != nil {
			return nil, err
		}
		result = append(result, record)
	}
	return result, nil
}

// One returns the first record on the result set and closes the result set.
func (rs *UserResultSet) One() (*User, error) {
	if !rs.Next() {
		return nil, kallax.ErrNotFound
	}

	record, err := rs.Get()
	if err != nil {
		return nil, err
	}

	if err := rs.Close(); err != nil {
		return nil, err
	}

	return record, nil
}

// Err returns the last error occurred.
func (rs *UserResultSet) Err() error {
	return rs.lastErr
}

// Close closes the result set.
func (rs *UserResultSet) Close() error {
	return rs.ResultSet.Close()
}

type schema struct {
	Poll       *schemaPoll
	PollOption *schemaPollOption
	PollVote   *schemaPollVote
	Session    *schemaSession
	User       *schemaUser
}

type schemaPoll struct {
	*kallax.BaseSchema
	ID        kallax.SchemaField
	CreatedAt kallax.SchemaField
	UpdatedAt kallax.SchemaField
	Name      kallax.SchemaField
	Owner     kallax.SchemaField
	Published kallax.SchemaField
}

type schemaPollOption struct {
	*kallax.BaseSchema
	ID      kallax.SchemaField
	OwnerFK kallax.SchemaField
	Content kallax.SchemaField
}

type schemaPollVote struct {
	*kallax.BaseSchema
	ID           kallax.SchemaField
	CreatedAt    kallax.SchemaField
	UpdatedAt    kallax.SchemaField
	PollID       kallax.SchemaField
	UserID       kallax.SchemaField
	ChosenOption kallax.SchemaField
}

type schemaSession struct {
	*kallax.BaseSchema
	ID             kallax.SchemaField
	CreatedAt      kallax.SchemaField
	UpdatedAt      kallax.SchemaField
	UserID         kallax.SchemaField
	RegisteredUser kallax.SchemaField
}

type schemaUser struct {
	*kallax.BaseSchema
	ID        kallax.SchemaField
	CreatedAt kallax.SchemaField
	UpdatedAt kallax.SchemaField
	Login     kallax.SchemaField
	Name      kallax.SchemaField
	Password  kallax.SchemaField
}

var Schema = &schema{
	Poll: &schemaPoll{
		BaseSchema: kallax.NewBaseSchema(
			"poll",
			"__poll",
			kallax.NewSchemaField("id"),
			kallax.ForeignKeys{
				"Options": kallax.NewForeignKey("poll_id", false),
			},
			func() kallax.Record {
				return new(Poll)
			},
			false,
			kallax.NewSchemaField("id"),
			kallax.NewSchemaField("created_at"),
			kallax.NewSchemaField("updated_at"),
			kallax.NewSchemaField("name"),
			kallax.NewSchemaField("owner"),
			kallax.NewSchemaField("published"),
		),
		ID:        kallax.NewSchemaField("id"),
		CreatedAt: kallax.NewSchemaField("created_at"),
		UpdatedAt: kallax.NewSchemaField("updated_at"),
		Name:      kallax.NewSchemaField("name"),
		Owner:     kallax.NewSchemaField("owner"),
		Published: kallax.NewSchemaField("published"),
	},
	PollOption: &schemaPollOption{
		BaseSchema: kallax.NewBaseSchema(
			"poll_option",
			"__polloption",
			kallax.NewSchemaField("id"),
			kallax.ForeignKeys{
				"Owner": kallax.NewForeignKey("poll_id", true),
			},
			func() kallax.Record {
				return new(PollOption)
			},
			false,
			kallax.NewSchemaField("id"),
			kallax.NewSchemaField("poll_id"),
			kallax.NewSchemaField("content"),
		),
		ID:      kallax.NewSchemaField("id"),
		OwnerFK: kallax.NewSchemaField("poll_id"),
		Content: kallax.NewSchemaField("content"),
	},
	PollVote: &schemaPollVote{
		BaseSchema: kallax.NewBaseSchema(
			"poll_vote",
			"__pollvote",
			kallax.NewSchemaField("id"),
			kallax.ForeignKeys{},
			func() kallax.Record {
				return new(PollVote)
			},
			false,
			kallax.NewSchemaField("id"),
			kallax.NewSchemaField("created_at"),
			kallax.NewSchemaField("updated_at"),
			kallax.NewSchemaField("poll_id"),
			kallax.NewSchemaField("user_id"),
			kallax.NewSchemaField("chosen_option"),
		),
		ID:           kallax.NewSchemaField("id"),
		CreatedAt:    kallax.NewSchemaField("created_at"),
		UpdatedAt:    kallax.NewSchemaField("updated_at"),
		PollID:       kallax.NewSchemaField("poll_id"),
		UserID:       kallax.NewSchemaField("user_id"),
		ChosenOption: kallax.NewSchemaField("chosen_option"),
	},
	Session: &schemaSession{
		BaseSchema: kallax.NewBaseSchema(
			"poll_session",
			"__session",
			kallax.NewSchemaField("id"),
			kallax.ForeignKeys{},
			func() kallax.Record {
				return new(Session)
			},
			false,
			kallax.NewSchemaField("id"),
			kallax.NewSchemaField("created_at"),
			kallax.NewSchemaField("updated_at"),
			kallax.NewSchemaField("user_id"),
			kallax.NewSchemaField("registered_user"),
		),
		ID:             kallax.NewSchemaField("id"),
		CreatedAt:      kallax.NewSchemaField("created_at"),
		UpdatedAt:      kallax.NewSchemaField("updated_at"),
		UserID:         kallax.NewSchemaField("user_id"),
		RegisteredUser: kallax.NewSchemaField("registered_user"),
	},
	User: &schemaUser{
		BaseSchema: kallax.NewBaseSchema(
			"poll_user",
			"__user",
			kallax.NewSchemaField("id"),
			kallax.ForeignKeys{},
			func() kallax.Record {
				return new(User)
			},
			false,
			kallax.NewSchemaField("id"),
			kallax.NewSchemaField("created_at"),
			kallax.NewSchemaField("updated_at"),
			kallax.NewSchemaField("login"),
			kallax.NewSchemaField("name"),
			kallax.NewSchemaField("password"),
		),
		ID:        kallax.NewSchemaField("id"),
		CreatedAt: kallax.NewSchemaField("created_at"),
		UpdatedAt: kallax.NewSchemaField("updated_at"),
		Login:     kallax.NewSchemaField("login"),
		Name:      kallax.NewSchemaField("name"),
		Password:  kallax.NewSchemaField("password"),
	},
}
