// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package app

import (
	"sync"
)

var (
	lockHTTPHelperMockProcess sync.RWMutex
)

// HTTPHelperMock is a mock implementation of HTTPHelper.
//
//     func TestSomethingThatUsesHTTPHelper(t *testing.T) {
//
//         // make and configure a mocked HTTPHelper
//         mockedHTTPHelper := &HTTPHelperMock{
//             ProcessFunc: func(v interface{}, blocks ...ProcessingBlock)  {
// 	               panic("mock out the Process method")
//             },
//         }
//
//         // use mockedHTTPHelper in code that requires HTTPHelper
//         // and then make assertions.
//
//     }
type HTTPHelperMock struct {
	// ProcessFunc mocks the Process method.
	ProcessFunc func(v interface{}, blocks ...ProcessingBlock)

	// calls tracks calls to the methods.
	calls struct {
		// Process holds details about calls to the Process method.
		Process []struct {
			// V is the v argument value.
			V interface{}
			// Blocks is the blocks argument value.
			Blocks []ProcessingBlock
		}
	}
}

// Process calls ProcessFunc.
func (mock *HTTPHelperMock) Process(v interface{}, blocks ...ProcessingBlock) {
	if mock.ProcessFunc == nil {
		panic("HTTPHelperMock.ProcessFunc: method is nil but HTTPHelper.Process was just called")
	}
	callInfo := struct {
		V      interface{}
		Blocks []ProcessingBlock
	}{
		V:      v,
		Blocks: blocks,
	}
	lockHTTPHelperMockProcess.Lock()
	mock.calls.Process = append(mock.calls.Process, callInfo)
	lockHTTPHelperMockProcess.Unlock()
	mock.ProcessFunc(v, blocks...)
}

// ProcessCalls gets all the calls that were made to Process.
// Check the length with:
//     len(mockedHTTPHelper.ProcessCalls())
func (mock *HTTPHelperMock) ProcessCalls() []struct {
	V      interface{}
	Blocks []ProcessingBlock
} {
	var calls []struct {
		V      interface{}
		Blocks []ProcessingBlock
	}
	lockHTTPHelperMockProcess.RLock()
	calls = mock.calls.Process
	lockHTTPHelperMockProcess.RUnlock()
	return calls
}
